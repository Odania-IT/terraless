package main

import (
	"bytes"
	"fmt"
	"github.com/Odania-IT/terraless/config"
	"github.com/Odania-IT/terraless/schema"
	"github.com/Odania-IT/terraless/support"
	"github.com/Odania-IT/terraless/templates"
	"github.com/Odania-IT/terraless/terraless_provider_aws"
	"github.com/sirupsen/logrus"
	"gopkg.in/alecthomas/kingpin.v2"
	"path/filepath"
	"strings"
)

var terralessProviders []schema.Provider

func detectTerralessProviders() []schema.Provider {
	var terralessProviders []schema.Provider
	terralessProviders = append(terralessProviders, terraless_provider_aws.Provider())

	return terralessProviders
}

func main() {
	logrus.SetFormatter(&logrus.TextFormatter{
		DisableLevelTruncation: true,
	})

	terralessProviders = append(terralessProviders, terraless_provider_aws.Provider())

	logrus.Info("Running terraless")
	arguments, kingpinResult := parseArguments()

	if kingpinResult == versionCommand.FullCommand() {
		versionInfo()
		return
	}

	terralessData := config.NewTerralessData(arguments, detectTerralessProviders())
	currentConfig := terralessData.Config

	logrus.Debugf("Active Providers in Config: %d\n", len(currentConfig.Providers))

	logrus.Debug("Config", currentConfig)

	switch kingpinResult {
	case deployCommand.FullCommand():
		logrus.Debug("Handling Deploy Command")
		stepDeploy(terralessData)
	case initCommand.FullCommand():
		logrus.Debug("Handling Init Command")
		stepInitialize(terralessData)
	case sessionCommand.FullCommand():
		logrus.Debug("Handling Session Command")
		stepPrepareSesssion(terralessData)
	case uploadCommand.FullCommand():
		logrus.Debug("Handling Upload Command")
		stepUpload(terralessData)
	case infoCommand.FullCommand():
		logrus.Debug("Handling Info Command")
		versionInfo()
		fmt.Println()
		fmt.Printf("Global Config: %s\n", arguments.GlobalConfig)
		fmt.Printf("Project Config: %s\n", arguments.Config)

		var allProviders []string
		for _, provider := range terralessData.Config.Providers {
			allProviders = append(allProviders, provider.Name)
		}
		fmt.Printf("Providers: %s\n", strings.Join(allProviders, ", "))
	default:
		logrus.Debug("Invalid step")
		kingpin.Usage()
	}
}

func versionInfo() {
	fmt.Printf("Terraless Version: %s [Codename: %s]\n", VERSION, CODENAME)
}

func stepDeploy(terralessData *schema.TerralessData) {

	stepInitialize(terralessData)
	stepPrepareSesssion(terralessData)

	arguments := terralessData.Arguments
	currentConfig := terralessData.Config
	if arguments.NoDeploy {
		logrus.Debug("Not deploying due to arguments....")
	} else {
		if currentConfig.Package.SourceDir != "" {
			logrus.Debugf("Executing before package hooks depending on runtime")
			if support.ContainsStartsWith(currentConfig.Runtimes, "ruby") {
				executeCommand(filepath.Join(currentConfig.SourcePath, currentConfig.Package.SourceDir), "bundle",
					[]string{
						"install", "--deployment", "--without", "test", "development",
					}, false)
			}
		}

		deployTerraform(currentConfig, arguments.Environment, arguments.ForceDeploy, arguments.TerraformCommand)

		if currentConfig.Package.SourceDir != "" {
			logrus.Debugf("Executing after package hooks depending on runtime")
			if support.ContainsStartsWith(currentConfig.Runtimes, "ruby") {
				executeCommand(filepath.Join(currentConfig.SourcePath, currentConfig.Package.SourceDir), "bundle",
					[]string{
						"install", "--quiet", "--no-deployment", "--with", "test", "development",
					}, false)
			}
		}
	}

	if arguments.NoUpload {
		logrus.Debug("Not uploading due to arguments....")
	} else {
		templates.ProcessUploads(*terralessData)
	}
}

func stepInitialize(terralessData *schema.TerralessData) {
	buffer := bytes.Buffer{}
	buffer = templates.Render(terralessData, buffer)

	if buffer.Len() == 0 {
		logrus.Debug("Nothing to write to terraless-resources.tf")
		return
	}

	// Writing buffer to file
	targetFileName := filepath.Join(terralessData.Config.SourcePath, "terraless-resources.tf")
	logrus.Debugf("Writing file %s\n", targetFileName)

	finalBuffer := bytes.Buffer{}
	finalBuffer.WriteString("# This file is generated by Terraless\n\n")
	finalBuffer.Write(buffer.Bytes())
	support.WriteToFile(targetFileName, finalBuffer)
}

func stepPrepareSesssion(terralessData *schema.TerralessData) {
	for _, terralessProvider := range terralessProviders {
		terralessProvider.PrepareSession(terralessData.Config)
	}
}

func stepUpload(terralessData *schema.TerralessData) {
	stepInitialize(terralessData)
	stepPrepareSesssion(terralessData)
	templates.ProcessUploads(*terralessData)
}

func deployTerraform(config schema.TerralessConfig, environment string, forceDeploy bool, terraformCommand string) {
	logrus.Info("Executing terraform init")
	executeCommand(config.SourcePath, terraformCommand, []string{"init"}, false)
	logrus.Info("Creating new terraform workspace")
	executeCommand(config.SourcePath, terraformCommand, []string{"workspace", "new", config.ProjectName}, true)
	logrus.Info("Selecting new terraform workspace")
	executeCommand(config.SourcePath, terraformCommand, []string{"workspace", "select", config.ProjectName}, false)

	logrus.Info("Executing terraform plan")
	planArgs := []string{
		"plan",
		"-out",
		"terraform.plan",
		"-input=false",
		"-var",
		"environment=" + environment,
	}
	executeCommand(config.SourcePath, terraformCommand, planArgs, false)

	if forceDeploy || checkApprove() {
		logrus.Info("Deploying terraform plan")
		executeCommand(config.SourcePath, terraformCommand, []string{"apply", "-input=false", "terraform.plan"}, false)
	} else {
		logrus.Info("Not deploying...")
	}
}
